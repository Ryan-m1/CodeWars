# 💻2021-11

## ⭐11-03

### [🉑62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

#### 👉解题思路(一)：

深度优先搜索，机器人每次只能向下或者向右移动一步，实际上可以将机器人走过的路径抽象为一颗二叉树，而叶子节点就是终点。

![image-20211103223103987](../img/image-20211103223103987.png)

![image-20211103223039144](../img/image-20211103223039144.png)

转化为求二叉树叶子节点的个数。

然而超时了，时间复杂度太高。


**代码：**

```java
class Solution {
    public int uniquePaths(int m, int n) {
        return dsf(1, 1, m, n);
    }

    public int dsf(int i, int j, int m, int n) {
        if (i > m || j > n) return 0;
        //找到叶子节点，相当于找到一种符合方案
        if (i == m && j == n) return 1;
        return dsf(i + 1, j, m, n) + dsf(i, j + 1, m, n);
    }
}
```

***

#### 👉解题思路(二)：

**动态规划经典题**

机器人从(0 , 0) 位置触发，到(m - 1, n - 1)终点。

1. 确定dp数组(dp table)以及下标的含义

> dp[i][j] :表示从(0 ，0)出发，到(i, j) 有dp[i][j]条不同的路径。

2. 确定递推公式

>  dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和 dp[i][j - 1]。
>
> dp[i][j] = dp[i - 1][j] + dp[i][j - 1]

3. dp数组的初始化

首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同

理。

>for (int i = 0; i < m; i++) dp[i][0] = 1;
>
>for (int j = 0; j < n; j++) dp[0][j] = 1;

4. 确定遍历顺序

从左到右一层一层遍历

**代码：**

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```

***

时间复杂度:O(m * n) 

空间复杂度:O(m * n)

