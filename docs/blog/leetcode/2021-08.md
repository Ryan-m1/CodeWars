# 💻2021-08

## ⭐08-03

### [🉑581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

#### 👉解题思路：

先对数组排序 将排序后的数组与原始数组进行比较，分别找出不一样的最左和最右的索引，最左索引和最右索引之间的元素个数就是符合题意的最短子数组

时间复杂度O(n)

**代码：**

```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int n = nums.length;
        int[] newNums = nums.clone();
        Arrays.sort(newNums);
        int i = 0, j = n - 1;
        while (i <= j && nums[i] == newNums[i]) i++;
        while (i <= j && nums[j] == newNums[j]) j--;
        return j - i + 1;
    }
}
```

***

## ⭐08-04

### [🉑611. 有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/)

#### 👉解题思路（1）：

三层for循环暴力解题 先对数组排序，下标由后往前依次遍历，防止重复统计，否则会超时 由于数组已排序，记录满足后前两项相加>第三项的三元组

时间复杂度O(n3)

**代码：**

```java
class Solution {
    public int triangleNumber(int[] nums) {
        int length = nums.length;
        Arrays.sort(nums);
        int sum = 0;
        for (int x = 0; x < length; x++) {
            for (int y = x - 1; y >= 0; y--) {
                for (int z = y - 1; z >= 0; z--) {
                    //由于数组已排序，当满足后前两项相加>第三项 即符合要求
                    if (nums[y] + nums[z] > nums[x]) sum++;
                }
            }
        }
        return sum;
    }
}
```

#### 👉解题思路（2）：

双指针求解,首先还是先排序，三元组设为(x,y,z)和上题解一样，一直满足x<y<z 当满足nums[x]+nums[y]>nums[z] 符合题意 sum++

先固定3个下标中的k替代z，使用对撞指针 left, right 替代x,y 条件变更为nums[left]+nums[right]>nums[k] 符合题意sum++
时间复杂度O(n2)
**代码：**

```java
class Solution {
    public int triangleNumber(int[] nums) {
        if (nums.length < 3) {
            return 0;
        }
        Arrays.sort(nums);
        int sum = 0;
        //固定k (k开始=len-1, 最后k>=2), 剩下两个数用双指针找
        for (int k = nums.length - 1; k >= 2; k--) {
            //双指针
            int left = 0;
            int right = k - 1;
            while (left < right) {
                //k确定了以后，由于是排序之后的数组，只要有一次符合题意 剩下的肯定就符合，统计right-left即可
                if (nums[left] + nums[right] > nums[k]) {
                    sum += right - left;
                    //右指针左移
                    right--;
                } else {
                    //左指针右移
                    left++;
                }
            }
        }
        return sum;
    }
}
```

***

## ⭐08-05

### [🉑802. 找到最终的安全状态](https://leetcode-cn.com/problems/find-eventual-safe-states/)

#### 👉解题思路（1）：

**代码：**

```java

```

#### 👉解题思路（2）：

**代码：**

```java

```

***