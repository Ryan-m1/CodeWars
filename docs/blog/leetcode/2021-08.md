# 💻2021-08

## ⭐08-03

### [🉑581. 最短无序连续子数组](https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/)

#### 👉解题思路：

先对数组排序 将排序后的数组与原始数组进行比较，分别找出不一样的最左和最右的索引，最左索引和最右索引之间的元素个数就是符合题意的最短子数组

时间复杂度O(n)

**代码：**

```java
class Solution {
    public int findUnsortedSubarray(int[] nums) {
        int n = nums.length;
        int[] newNums = nums.clone();
        Arrays.sort(newNums);
        int i = 0, j = n - 1;
        while (i <= j && nums[i] == newNums[i]) i++;
        while (i <= j && nums[j] == newNums[j]) j--;
        return j - i + 1;
    }
}
```

***

## ⭐08-04

### [🉑611. 有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/)

#### 👉解题思路（1）：

三层for循环暴力解题 先对数组排序，下标由后往前依次遍历，防止重复统计，否则会超时 由于数组已排序，记录满足后前两项相加>第三项的三元组

时间复杂度O(n3)

**代码：**

```java
class Solution {
    public int triangleNumber(int[] nums) {
        int length = nums.length;
        Arrays.sort(nums);
        int sum = 0;
        for (int x = 0; x < length; x++) {
            for (int y = x - 1; y >= 0; y--) {
                for (int z = y - 1; z >= 0; z--) {
                    //由于数组已排序，当满足后前两项相加>第三项 即符合要求
                    if (nums[y] + nums[z] > nums[x]) sum++;
                }
            }
        }
        return sum;
    }
}
```

#### 👉解题思路（2）：

双指针求解,首先还是先排序，三元组设为(x,y,z)和上题解一样，一直满足x<y<z 当满足nums[x]+nums[y]>nums[z] 符合题意 sum++

先固定3个下标中的k替代z，使用对撞指针 left, right 替代x,y 条件变更为nums[left]+nums[right]>nums[k] 符合题意sum++ 时间复杂度O(n2)

**代码：**

```java
class Solution {
    public int triangleNumber(int[] nums) {
        if (nums.length < 3) {
            return 0;
        }
        Arrays.sort(nums);
        int sum = 0;
        //固定k (k开始=len-1, 最后k>=2), 剩下两个数用双指针找
        for (int k = nums.length - 1; k >= 2; k--) {
            //双指针
            int left = 0;
            int right = k - 1;
            while (left < right) {
                //k确定了以后，由于是排序之后的数组，只要有一次符合题意 剩下的肯定就符合，统计right-left即可
                if (nums[left] + nums[right] > nums[k]) {
                    sum += right - left;
                    //右指针左移
                    right--;
                } else {
                    //左指针右移
                    left++;
                }
            }
        }
        return sum;
    }
}
```

***

## ⭐08-05

### [🉑802. 找到最终的安全状态](https://leetcode-cn.com/problems/find-eventual-safe-states/)

#### 👉解题思路（1）：

**代码：**

```java

```

#### 👉解题思路（2）：

**代码：**

```java

```

***

## ⭐08-06

### [🉑847. 访问所有节点的最短路径](https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/)

#### 👉解题思路（1）：

**代码：**

```java

```

#### 👉解题思路（2）：

**代码：**

```java

```

***

## ⭐08-07

### [🉑457. 环形数组是否存在循环](https://leetcode-cn.com/problems/circular-array-loop/)

#### 👉解题思路（1）：

第一瞬间想到的解题思路，时间复杂度O(n2) 空间复杂度O(n)  奈何最后两例超时,换了一种思路

**代码：**

```java
     class Solution {

    public boolean circularArrayLoop(int[] nums) {
        int length = nums.length;
        for (int k = 0; k < length; k++) {
            if (solve(k, nums)) {
                return true;
            }
        }
        return false;
    }

    public boolean solve(int i, int[] nums) {
        List<Integer> numList = new ArrayList<>();
        int length = nums.length;
        numList.add(i);
        boolean flag = nums[i] > 0;
        while (true) {
            i = ((i + nums[i]) % length + length) % length;
            if (numList.contains(i)) {
                numList.add(i);
                break;
            }
            numList.add(i);
            if (flag && nums[i] < 0) return false;
            if (!flag && nums[i] > 0) return false;
        }
        if (numList.size() <= 1) {
            return false;
        }

        if (Objects.equals(numList.get(0), numList.get(numList.size() - 1))) {
            if (numList.size() == 2) {
                return false;
            }
        } else {
            return false;
        }
        return true;
    }
}
```

#### 👉解题思路（2）：

循环遍历，以每一个下标为基准进行check。

next下标获取方式：int next = ((cur + nums[cur]) % len + len) % len;

当获取到的下标值负数时，加上数组长度 len，再余len即可得到对应下标。但注意当负数很大时，加一个len 会不够，所以需要先对负数模len，再加上len。接着再取模len以确保本身是正数时的正确性

check的过程中，可以进行适当优化

1. 根据 [抽屉原理](https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/233776)
   得知如果check过程中扫描的数量sum超过了数组长度len，那么必然有数被重复处理了，同时条件一并不符合，因此再处理下去，也不会到达与起点相同的下标。
2. 如果在check过程中，找到了与起点相同的下标,且sum>1，说明存在符合条件的环。
3. 处理过程中如果发现不全是正数或者负数 说明不存在符合条件的环。

**代码：**

```java
 class Solution {

    public boolean circularArrayLoop(int[] nums) {
        int len = nums.length;
        for (int k = 0; k < len; k++) {
            if (solve(k, nums)) {
                return true;
            }
        }
        return false;
    }

    public boolean solve(int start, int[] nums) {
        int cur = start;
        int len = nums.length;
        boolean flag = nums[start] > 0;
        int sum = 1;
        while (true) {
            //抽屉原理
            if (sum > len) return false;
            int next = ((cur + nums[cur]) % len + len) % len;
            //如果在check过程中，找到了与起点相同的下标,且sum>1，说明存在符合条件的环。
            if (flag && nums[next] < 0) return false;
            if (!flag && nums[next] > 0) return false;
            // 如果在check过程中，找到了与起点相同的下标,且sum>1，说明存在符合条件的环。
            if (start == next) return sum > 1;
            cur = next;
            sum++;
        }
    }
}
```

***
